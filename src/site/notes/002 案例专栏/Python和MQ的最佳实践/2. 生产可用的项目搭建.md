---
{"dg-publish":true,"permalink":"/002/python-mq/2/","created":"2024-05-28T15:22:21.461+08:00","updated":"2024-05-31T14:59:27.842+08:00"}
---

# Conda

Conda 是一个流行的开源**软件包管理**系统和**环境管理**系统，用于安装和管理软件包及其依赖项。使用 Conda，你可以轻松地创建、导出、分享和重现环境。
{ #9d25a3}

## 安装 anaconda

Miniconda 是一个轻量级的 Conda 版本，包含最小的 Conda 安装和 Python。Anaconda 包含了预先安装了许多常用的数据科学软件包的完整版 Conda。

在官网下载并安装 [Download Success | Anaconda](https://www.anaconda.com/download-success)
## conda 在 zsh 中的美化

参见：
1.  [GitHub - lyytaw/taw-ys.zsh-theme: 基于ys的定制化oh-my-zsh主题，支持python的prompt显示](https://github.com/lyytaw/taw-ys.zsh-theme)
2.  [oh-my-zsh主题支持conda虚拟环境 | 谷河|BLOG](https://www.lyytaw.com/杂项/oh-my-zsh主题支持conda虚拟环境/#修改zsh主题)

步骤：
1. 将 taw-ys-conda.zsh-theme 文件拷贝到~/.oh-my-zsh/themes 下
2. 修改~/.zshrc 中的 theme 配置为 taw-ys-conda
3. 在~/.condarc 中添加 `changeps1: False`

美化预览：

![Pasted image 20240528161825.png](/img/user/$/$Sys999%20Attachment/Pasted%20image%2020240528161825.png)
## conda 的基本命令

1. **创建环境**：使用 `conda create` 命令创建一个新的 Conda 环境。例如，要创建一个名为 `bias-alg` 的环境并安装 Python 3.8，可以运行以下命令：

```zsh
conda create --name bias-alg python=3.8
```

2. **激活环境**：创建环境后，需要激活它才能使用。在 Unix 和类 Unix 系统中，可以运行以下命令：

```zsh
conda activate bias-alg
```

3. **安装依赖**：激活环境后，你可以使用 Conda 安装所需的软件包。例如：

```zsh
conda install package_name
```

4. **退出环境**：当你完成工作后，可以通过运行以下命令来退出环境：

```zsh
conda deactivate
```

5. **查看环境列表**：

```zsh
conda env list
```

6. **删除指定环境**

```zsh
conda env remove -n bias-alg
```
## conda 管理项目依赖

1. 导出项目环境到一个 YAML 文件

```zsh
conda env export > environment.yml
```

2. 安装依赖并重新导出 YAML 文件

```zsh
conda install -n bias-alg matplotlib 
conda env export > environment.yml
```

3. 使用 environment.yml 文件更新环境依赖

```zsh
# 不会删除environment.yml中为列出的依赖
conda env update -f environment.yml

# 保证环境中的依赖和environment.yml保持一致（包括删除多余的依赖项）
conda env update -f environment.yml --prune
```

4. 列出环境中的包

```zsh
conda list
```
## 修改 idea 的虚环境

![Pasted image 20240528171500.png](/img/user/$/$Sys999%20Attachment/Pasted%20image%2020240528171500.png)
# Django
## 安装

```zsh
conda install django
conda env export > environment.yml
```
## 创建 Django 站点

详细教程参见: [编写你的第一个 Django 应用，第 1 部分 | Django 文档 | Django](https://docs.djangoproject.com/zh-hans/5.0/intro/tutorial01/)

```
django-admin startproject root
```

>[! note] 更换端口
>默认情况下，[`runserver`](https://docs.djangoproject.com/zh-hans/5.0/ref/django-admin/#django-admin-runserver) 命令会将服务器设置为监听本机内部 IP 的 8000 端口。
>如果你想更换服务器的监听端口，请使用命令行参数。举个例子，下面的命令会使服务器监听 8080 端口：
>$ python manage.py runserver 8080
>$ python manage.py runserver 0.0.0.0:8000

调整目录结构如下：

![Pasted image 20240528174306.png](/img/user/$/$Sys999%20Attachment/Pasted%20image%2020240528174306.png)

- 最外层的 `mysite/` 根目录只是你项目的容器， 根目录名称对 Django 没有影响，你可以将它重命名为任何你喜欢的名称。
- `manage.py`: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 [django-admin 和 manage.py](https://docs.djangoproject.com/zh-hans/5.0/ref/django-admin/) 获取所有 `manage.py` 的细节。
- 里面一层的 `mysite/` 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 `mysite.urls`).
- `mysite/__init__.py`：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 [更多关于包的知识](https://docs.python.org/3/tutorial/modules.html#tut-packages "(在 Python v3.12)")。
- `mysite/settings.py`：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 [Django 配置](https://docs.djangoproject.com/zh-hans/5.0/topics/settings/) 了解细节或者参见[Django配置文件 | 大江狗的博客](https://pythondjango.cn/django/basics/17-settings/)。
- `mysite/urls.py`：Django 项目的 URL 声明，就像你网站的“目录”。阅读 [URL调度器](https://docs.djangoproject.com/zh-hans/5.0/topics/http/urls/) 文档来获取更多关于 URL 的内容。
- `mysite/asgi.py`：作为你的项目的运行在 ASGI 兼容的 Web 服务器上的入口。阅读 [如何使用 ASGI 来部署](https://docs.djangoproject.com/zh-hans/5.0/howto/deployment/asgi/) 了解更多细节。
- `mysite/wsgi.py`：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 [如何使用 WSGI 进行部署](https://docs.djangoproject.com/zh-hans/5.0/howto/deployment/wsgi/) 了解更多细节。
## Pycharm 配置运行 Django 项目

![Pasted image 20240528200442.png](/img/user/$/$Sys999%20Attachment/Pasted%20image%2020240528200442.png)
## 创建一个 Demo 应用

>[!note] 项目 VS 应用
>项目和应用有什么区别？应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者小型的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。

```
python manage.py startapp demo_app
```

目录结构：

![Pasted image 20240528195748.png](/img/user/$/$Sys999%20Attachment/Pasted%20image%2020240528195748.png)
## 设置 Django 启动运行代码

1. 修改 test_alg_app 下的 apps 文件：

```Python
from django.apps import AppConfig  
from test_alg_app.python.test_alg import test_alg_main  
  
  
class DemoAppConfig(AppConfig):  
    default_auto_field = 'django.db.models.BigAutoField'  
    name = 'test_alg_app'  
  
    def ready(self):  
        test_alg_main()
```

2. 修改 bias_alg 模块下 Seeting.py 文件钟的 INSTALLED_APPS 选项：

```python
INSTALLED_APPS = [  
    'django.contrib.admin',  
    'django.contrib.auth',  
    'django.contrib.contenttypes',  
    'django.contrib.sessions',  
    'django.contrib.messages',  
    'django.contrib.staticfiles',  
    'test_alg_app.apps.DemoAppConfig'  
]
```

此时通过  python manage.py runserver 启动项目时，DemoAppConfig 下的 ready 会自动执行。
## Django 多环境配置文件

1. 安装 python-doenv

```zsh
pip install python-dotenv
conda env export > environment.yml
```

2. 创建.env 和不同的配置文件.env.test;.env.prod 等

```text
#.env
REDIS_HOST='127.0.0.1' 
REDIS_PORT='6379' 
REDIS_PASSWORD='' 
REDIS_DB='1' 
REDIS_MODE='single'
```

3. 加载环境变量

```python
# seeting.py

from dotenv import dotenv_values

# 处理环境变量  
env_vars = dotenv_values(str(BASE_DIR / '.env'))  
  
APP_ENV = os.environ.get('APP_ENV', 'dev')  
env_file = f'.env.{APP_ENV}'  
  
env_vars.update(dotenv_values(str(BASE_DIR / env_file)))  
  
for key, value in env_vars.items():  
    os.environ[key] = value
```

在其他文件中使用环境变量：

```python
# xxx.py
from os import environ  
  
def test_alg_main():  
    print(environ.get('ENV', 'hello'))
```
# RockerMQ

详细信息见官网：[为什么选择RocketMQ | RocketMQ](https://rocketmq.apache.org/zh/docs/) 
## Docker 安装

1. **Start NameServer**
```zsh
$ docker run -it --name rocketmq-nameserver --net=host apache/rocketmq ./mqnamesrv
```

2. **Start Broker**
```zsh
$ docker run -it --name rocketmq-broker --net=host -v /Users/cloudswhite/person/software-data/rockerMQ/store:/home/rocketmq/store apache/rocketmq ./mqbroker -n localhost:9876
```

3. 安装rocketmq-dashboard
```zsh
$ docker pull apacherocketmq/rocketmq-dashboard:latest
$ docker run -d --name rocketmq-dashboard --net=host -e "JAVA_OPTS=-Drocketmq.namesrv.addr=10.0.0.199:9876" -t apacherocketmq/rocketmq-dashboard:latest
```

访问 `localhost:8080`

![Pasted image 20240529164417.png](/img/user/$/$Sys999%20Attachment/Pasted%20image%2020240529164417.png)
## 安装rocketmq-client-python

1. 安装 [rocketmq-client-cpp-2.0.0](https://github.com/apache/rocketmq-client-cpp/releases/tag/2.0.0)

参见：[GitHub - apache/rocketmq-client-python: Apache RocketMQ python client](https://github.com/apache/rocketmq-client-python)

```zsh
wget https://github.com/apache/rocketmq-client-cpp/releases/download/2.0.0/rocketmq-client-cpp-2.0.0-bin-release.darwin.tar.gz
tar -xzf rocketmq-client-cpp-2.0.0-bin-release.darwin.tar.gz
cd rocketmq-client-cpp
mkdir /usr/local/include/rocketmq
cp include/* /usr/local/include/rocketmq
cp lib/* /usr/local/lib
install_name_tool -id "@rpath/librocketmq.dylib" /usr/local/lib/librocketmq.dylib
```
# Redis

[rocketmq-client-cpp](https://github.com/apache/rocketmq-client-cpp) 在 M1 芯片上安装不了，老大权衡之后，决定换 Redis 做 MQ。

redis 发布/订阅模式使用参见 [[003 学习网站/PdaiTech/数据库/NoSQL-Redis/Redis进阶 - 消息传递：发布订阅模式详解\|Redis进阶 - 消息传递：发布订阅模式详解]]。Redis 直接使用测试环境的 Redis，不在做部署文档。

1. 安装依赖

```zsh
$ pip install redis
$ conda env export > environment.yml
```

2. 配置 Redis 连接参数

```
# .evn.dev
ENV='DEV_ENV'  
REDIS_HOST='data.swanlab.kanasinfo.cn'
REDIS_PORT='6379'  
REDIS_DB='6'
REDIS_MAX_CONNECTIONS='10'
REDIS_PASSWORD='redis'
```

3. 配置 RedisClient

```Python
import redis  
from os import environ  

class RedisClient:  
    _instance = None  
  
    @classmethod  
    def get_instance(cls):  
        if cls._instance is None:  
            cls._instance = redis.StrictRedis(  
                connection_pool=redis.ConnectionPool(  
                    host=environ.get('REDIS_HOST'),  
                    port=environ.get('REDIS_PORT'),  
                    db=environ.get('REDIS_DB'),  
                    password=environ.get('REDIS_PASSWORD')  
                )  
            )  
        return cls._instance  

redis_client = RedisClient.get_instance()
```

4. 使用

```Python
from bias_alg.config import redis_client  
import os  
  
def test_alg_main():    
    queue_key = os.environ.get("QUEUE_KEY")  
    channel_name = os.environ.get("CHANNEL_NAME")  
  
    # 模拟测试  
    my_array = ['element1', 'element2', 'element3']  
    redis_client.rpush(queue_key, *my_array)  
  
    element = redis_client.lpop(queue_key)  
    while element is not None:  
        # 处理判分  
        print(f"{element}")  
  
        # 发布判分结果  
        redis_client.publish(channel_name, str(f'{element} result is FALSE'))  
  
        element = redis_client.lpop(queue_key)  
```
# 日志

```python
# setting.py

# 给ADMINS发送邮件需要配置
ADMINS = (
 ('admin_name','your@gmail.com'),
)
MANAGERS = ADMINS

# 创建log文件的文件夹
LOG_DIR = os.path.join(BASE_DIR, "logs")
if not os.path.exists(LOG_DIR): 
    os.mkdir(LOG_DIR) 

# 基本配置，可以复用的
LOGGING = {  
    "version": 1,  
    "disable_existing_loggers": False,  # 禁用已经存在的logger实例  
    'filters': {  # 过滤器：哪些信息可以被输出 debug_true/debug_false 的都可以被输出  
        # 'require_debug_true': {  # 在debug=True下产生的一些日志信息，要不要记录日志，需要的话就在handlers中加上这个过滤器，不需要就不加  
        #     '()': 'django.utils.log.RequireDebugTrue',  
        # }        'require_debug_false': {  # 和上面相反  
            '()': 'django.utils.log.RequireDebugFalse',  
        },  
    },  
    "formatters": {  # 定义了两种日志格式  
        "verbose": {  # 详细  
            "format": "%(levelname)s %(asctime)s %(module)s "  
                      "%(process)d %(thread)d %(message)s"        },  
    },  
    "handlers": {  # 定义了三种日志处理方式  
        'file': {  # 对INFO级别以上信息以日志文件形式保存  
            'level': "INFO",  
            'class': 'logging.handlers.RotatingFileHandler',  # 滚动生成日志，切割  
            'filters': ['require_debug_false'],  
            'filename': os.path.join(LOG_DIR, 'django.log'),  # 日志文件名  
            'maxBytes': 1024 * 1024 * 10,  # 单个日志文件最大为10M  
            'backupCount': 5,  # 日志备份文件最大数量  
            'formatter': 'verbose',  # 简单格式  
            'encoding': 'utf-8',  # 放置中文乱码  
        },  
        "console": {  # 打印到终端console  
            "level": "DEBUG",  
            "class": "logging.StreamHandler",  
            "formatter": "verbose",  
        },  
    },  
    "root": {"level": "DEBUG", "handlers": ["console", "file"]},  
}
```