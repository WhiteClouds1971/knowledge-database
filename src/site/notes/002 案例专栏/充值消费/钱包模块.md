---
{"dg-publish":true,"permalink":"/002 案例专栏/充值消费/钱包模块/","dgPassFrontmatter":true,"created":"2024-07-03T09:21:45.439+08:00","updated":"2024-07-08T17:56:25.804+08:00"}
---

公司为一款 app 设计了一套 **支付与账单服务**，这也是我第一次直接开发涉及财务的模块。这里做一下记录，供以后参考。
# SQL 数据源的添加

因为这款 app 之前使用的主数据库一直都是 Mongo。但是 Mongo 对事务的支持不是太理想，财务又是一个相当依赖事务的业务。所以，首先为 app 添加一个 sql 数据源。

注意如果之前只使用 Mongo 的话注意查看一下启动类的@SpringBootApplication 注解

```kotlin
@EnableDiscoveryClient
@EnableFeignClients
@EnableRetry
@EnableScheduling
@ServletComponentScan
@EntityScan(value = ["com.kanasinfo", "com.swanlab"])
@EnableJpaRepositories(value = ["com.kanasinfo", "com.swanlab"])
//@SpringBootApplication(scanBasePackages=["com.kanasinfo", "com.swanlab"],exclude = [DataSourceAutoConfiguration::class])
@SpringBootApplication(scanBasePackages=["com.kanasinfo", "com.swanlab"])
@EnableMongoAuditing
class PythonLabServiceApplication

fun main(args: Array<String>) {
    runApplication<PythonLabServiceApplication>(*args)
}
```

要把@SpringBootApplication (scanBasePackages=["com.kanasinfo", "com.swanlab"], exclude = [DataSourceAutoConfiguration:: class]) 中的 exclude 选项去掉。
## 添加依赖

```xml
<dependency>  
    <groupId>com.kanasinfo</groupId>  
    <artifactId>kt-speedy-data-jpa</artifactId>  
    <version>${kt-speedy.version}</version>  
</dependency>
<dependency>  
    <groupId>mysql</groupId>  
    <artifactId>mysql-connector-java</artifactId>  
    <scope>runtime</scope>  
</dependency>
```
## 配置链接信息

```yml
datasource:
  password: root
  url: jdbc:mysql://ip:3306/database?useUnicode=true&characterEncoding=utf-8
  username: root
```
## 实体类

```kotlin
package com.swanlab.pythonlab.billing.model  
  
import com.kanasinfo.data.jpa.SupportModel  
import com.kanasinfo.ext.KUID  
import javax.persistence.Column  
import javax.persistence.Entity  
import javax.persistence.Id  
import javax.persistence.Table  
  
@Entity  
@Table(name = Test.TABLE_NAME)  
data class Test(  
    @Column(length = 19)  
    @Id  
    val id: String = KUID.get()  
):SupportModel() {  
    companion object {  
        const val TABLE_NAME = "test"  
    }  
  
    var test: String? = null  
}
```
## 数据模型

![Pasted image 20240704104952.png](/img/user/$/$Sys999%20Attachment/Pasted%20image%2020240704104952.png)
# 为 MySQL 添加事务

>关于 Spring 的事务相关知识，推荐阅读[Spring 事务详解 | JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-transaction.html)
## 开启事务

因为项目是混用 Mongo 和 MySQL 的。之前的 Mongo 都没有使用事务。所有我们在为 MySQL 开始事务的同时，兼容以前 Mongo 没有事务的代码

```kotlin
@EnableTransactionManagement  
class PythonLabServiceApplication  
  
fun main(args: Array<String>) {  
    runApplication<PythonLabServiceApplication>(*args)  
}
```

>@EnableTransactionManagement 会对已有的 Mongo 代码有影响吗？
>
>是的，添加 `@EnableTransactionManagement` 注解本身并不会直接影响现有的MongoDB操作。这个注解主要用于启用Spring的事务管理支持，特别是让 `@Transactional` 注解在服务类或方法上生效，以便管理那些支持事务的数据源操作，如JDBC（对应MySQL等关系型数据库）。
>
>对于 MongoDB，虽然 MongoDB 4.0 及以上版本支持多文档事务，但 Spring 中要使用 MongoDB 事务，需要配置一个 `MongoTransactionManager` 并确保在执行事务性操作的方法上使用 `@Transactional` 注解。然而，如果不特别为 MongoDB 配置事务管理器，并且在 MongoDB 操作的方法上也没有使用 `@Transactional` 注解，那么即使启用了全局的事务管理，MongoDB 的操作也会按照非事务方式执行。
>
>因此，简单添加 `@EnableTransactionManagement` 注解，并不会自动让你的 MongoDB 操作变为事务性的，它主要服务于那些配置好的、支持事务的数据访问层。对于 MongoDB，除非你明确配置和使用，否则该注解不会改变其默认的非事务行为。
## Transactional 使用

因为系统目前设计的BusinessException 异常是集成自 Exception 所有为了能正确回滚所以 Transactional 要这么写

```kotlin
@Transactional(rollbackFor = [BusinessException::class])  
fun rechargeOnPage(holderId: String, amount: BigDecimal) {  
    recharge(holderId, amount)  
}
```
# 账户模块
## 集成微信支付
### 导入依赖

```xml
<dependency>  
    <groupId>com.github.binarywang</groupId>  
    <artifactId>weixin-java-pay</artifactId>  
    <version>4.4.4.B</version>  
</dependency>
```

